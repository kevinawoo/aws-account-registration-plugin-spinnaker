package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"time"
)

var accounts = make(map[string]AutoGeneratedAccount)

func hello(w http.ResponseWriter, req *http.Request) {
	fmt.Println("weeee")
	lt := req.URL.Query().Get("after")
	var r_accs []AutoGeneratedAccount
	if lt != "" {
		lti, err := strconv.ParseInt(lt, 10, 64)
		if err != nil {
			fmt.Println(err)
		}
		if modified(lti) {
			newAccounts := loadJSON()
			for _, v := range newAccounts.Accounts {
				accounts[v.AccountName] = v
			}
			for _, a := range accounts {
				r_accs = append(r_accs, a)
			}
		}
	} else {
		for _, v := range accounts {
			r_accs = append(r_accs, v)
		}

	}

	t := time.Now().UnixNano()
	resp := Response{
		Accounts:  r_accs,
		Bookmark: t,
	}
	fmt.Println(resp)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(resp)
}

func modified(t int64)  bool {
	info, err := os.Stat("response.json")
	if err != nil {
		fmt.Println(err)
	}
	if t < info.ModTime().UnixNano() {
		return true
	}
	return false

}

func loadJSON() AutoGenerated {
	var accs AutoGenerated
	file, err := os.Open("response.json")
	if err != nil {
		fmt.Println("Err opening file")
		return accs
	}
	defer file.Close()

	dec := json.NewDecoder(file)
	err = dec.Decode(&accs)
	if err != nil {
		fmt.Println("Error decoding")
		return accs
	}
	return accs
}

func main() {
	accs := loadJSON()
	for _, v := range accs.Accounts {
		accounts[v.AccountName] = v
	}
	http.HandleFunc("/hello", hello)
	http.ListenAndServe(":8080", nil)
}

type Account struct {
	Name       string   `json:"name"`       // required. MUST be unique.
	AccountId  string   `json:"accountId"`  // required
	AssumeRole string   `json:"assumeRole"` // required
	Regions    []string `json:"regions"`    // required
	Providers  []string `json:"providers"`  // required. ec2, ecs, and/or lambda
	Enabled    bool     `json:"enabled"`    // required
	// optional fields below.
	Type       string   `json:"type"`
	DeletedAt             int64       `json:"deletedAt"` //provide if deleted, else leave empty.
	Permissions           Permissions `json:"permissions"`
	Environment           string      `json:"environment"`
	DefaultKeyPair        string      `json:"defaultKeyPair"`
	DefaultSecurityGroups []string    `json:"defaultSecurityGroups"`
}

type Response struct {
	Accounts  []AutoGeneratedAccount `json:"accounts"`
	Bookmark int64     `json:"Bookmark"` // required
	Removed []string `json:"removed"`
}

type Region struct {
	Name              string   `json:"name"`
	Deprecated        bool     `json:"deprecated"`
	AvailabilityZones []string `json:"availabilityZones"`
	PreferredZones    []string `json:"preferredZones"`
}

type Permissions struct {
	READ    []string `json:"READ"`
	WRITE   []string `json:"WRITE"`
	EXECUTE []string `json:"EXECUTE"`
}
type AutoGenerated struct {
	Accounts []AutoGeneratedAccount `json:"Accounts"`
	Pagination struct {
		Limit       string `json:"Limit"`
		NextURL     string `json:"NextUrl"`
		CursorState string `json:"CursorState"`
	} `json:"Pagination"`
}

type AutoGeneratedAccount struct {
	AccountID           string   `json:"AccountId"`
	AccountArn          string   `json:"AccountArn"`
	AccountEmail        string   `json:"AccountEmail"`
	AccountName         string   `json:"AccountName"`
	Environment         string   `json:"Environment"`
	Profile             string   `json:"Profile"`
	Regions             []string `json:"Regions"`
	ServiceID           string   `json:"ServiceId"`
	Status              string   `json:"Status"`
	SpinnakerAssumeRole string   `json:"SpinnakerAssumeRole"`
	SpinnakerProviders  []string `json:"SpinnakerProviders"`
	SpinnakerEnabled    bool     `json:"SpinnakerEnabled"`
	CreatedAt           string   `json:"CreatedAt"`
	UpdatedAt           string   `json:"UpdatedAt"`
}